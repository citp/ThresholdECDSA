/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */package paillierp.key;

import java.math.BigInteger;

import paillierp.ByteUtils;


/**
 * A public key for the threshold Paillier cryptosystem
 * <i>CS</i><sub>1</sub>. 
 * Provides encryption credentials to encrypt, as well as the public
 * variables and values needed for the threshold variant of the Paillier
 * Public Key System.  This threshold key includes the public key needed
 * to encrypt a message (i.e. the <i>n</i> and <i>g</i> needed) and the
 * public values needed to verify messages in the threshold scheme (i.e.
 * the verifier <i>v</i> and the public verifier <i>v<sub>i</sub></i>
 * for each decryption server).
 * <p>
 * The public key for the threshold variant is nothing more than the
 * <i>n</i> and <i>g</i> as provided for in {@link PaillierKey} and the
 * following additional public variables:
 * <ul>
 *   <li><i>l</i> is the total number of decryption servers
 *   <li><i>w</i> is the threshold minimum number of decryption servers needed to 
 *       decrypt a message; <i>w</i> must be less than or equal to half of
 *       <i>l</i>
 *   <li><i>v</i> is a number used to verify actions of the decryption servers.
 *       This value <i>v</i> generates the cyclic group of squares in
 *       <i>Z</i><sup>*</sup><sub><i>n</i><sup><i>s+1</i></sup></sub>
 *   <li><i>v<sub>i</sub></i> is a verification key unique to each decryption
 *       server <i>i</i>.  The key <i>v<sub>i</sub></i> should be equal to
 *       <i>v</i><sup>&Delta;<i>s<sub>i</sub></i></sup> where &Delta;=<i>l</i>!
 *       (i.e. &Delta; is the factorial of the number of decryption servers).
 * </ul>
 * <p>
 * The set of verification keys {<i>v<sub>i</sub></i>} is generated by the key
 * generator and passed as an argument to this class, as well as all the above
 * mentioned variables.
 * <p>
 * The public information contained in this key is sufficient to completely
 * decrypt a ciphertext <i>c</i>, <i>given the k&ge;w partial decryptions
 * c<sub>1</sub>,...,c<sub>k</sub></i>.
 * <p>
 * <b>NOTE:</b> This is for the implementation where <i>s</i>=1.
 * 
 * @author James Garrity
 * @author Sean Hall
 * @see paillierp.PaillierThreshold
 */
public class PaillierThresholdKey extends PaillierKey {

	/*
	 * 
	 * Fields
	 * 
	 */
	
	/**
	 * This Serial ID
	 */
	private static final long serialVersionUID = -7453847065116591940L;

	/** 
	 * Generates a cyclic group of squares in
	 * <i>Z</i><sup>*</sup><sub><i>n</i><sup>2</sup></sub>.
	 */
	protected BigInteger v = null;
	
	/**
	 * Verification key for each of the <code>l</code> decryption servers.
	 * In essence,
	 * <i>v<sub>i</sub></i>=<i>v</i><sup><i>&Delta;s<sub>i</sub></i></sup>.
	 */
	protected BigInteger[] vi = null;
	
	/** Number of decryption servers <i>L</i>. */
	protected int l;
	//l is only needed to compute delta
	
	/** &Delta;=<i>L</i>!; this is used often in decryption algorithms. */
	protected BigInteger delta;
	
	/**
	 * The minimum of decryption servers needed to make a correct decryption.
	 */
	protected int w;
	// I don't think w is needed anywhere except for the key generation

	/**
	 * The cached value of (4&Delta;<sup>2</sup>)<sup>-1</sup> mod
	 * <i>n<sup>s</sup></i>
	 */
	private BigInteger combineSharesConstant;
	
	//TODO add the value s in the public key (if s is anything else but 1)
	
	/*
	 * 
	 * Constructors
	 * 
	 */
	
	/**
	 * Creates a new public key for the generalized Paillier threshold scheme
	 * from the given modulus <code>n</code>, for use on <code>l</code>
	 * decryption servers, <code>w</code> of which are needed to decrypt
	 * any message encrypted by using this public key.  The values
	 * <code>v</code> and <code>vi</code> correspond to the public
	 * values <i>v</i> and
	 * <i>v<sub>i</sub></i>=<i>v</i><sup><i>l</i>!<i>s<sub>i</sub></i></sup>
	 * needed to verify the zero knowledge proofs.
	 * 
	 * @param n         a safe prime product of <i>p</i> and <i>q</i> where
	 *                  <i>p'</i>=(<i>p</i>-1)/2 and <i>a'</i>=(<i>a</i>-1)/2
	 *                  are also both primes
	 * @param l         number of decryption servers
	 * @param w         threshold of servers needed to successfully decrypt any
	 *                  ciphertext created by this public key.
	 * @param v         a generator of a cyclic group of squares in
	 *                  <i>Z</i><sup>*</sup><sub><code>n</code><sup>2</sup></sub>
	 * @param viarray   array of verification keys where <code>vi[i]</code> is
	 *                  <code>v</code><sup><code>l</code>!<i>s</i><sub><code>i</code></sub></sup>
	 *                  where <i>s</i><sub><code>i</code></sub> is the private key
	 *                  for decryption server <code>i</code>
	 * @param seed      a long integer needed to start a random number generator
	 */
	public PaillierThresholdKey(BigInteger n, int l, int w, BigInteger v, BigInteger[] viarray, long seed) {
		super(n, seed);
		this.l = l;
		this.delta = KeyGen.factorial(l);
		this.combineSharesConstant = BigInteger.valueOf(4).multiply(delta.multiply(delta)).modInverse(ns);
		this.w = w;
		this.v = v;
		this.vi = viarray;
	}

	/**
	 * Creates a new public key for the generalized Paillier threshold scheme
	 * from the given modulus <code>n</code>, for use on <code>l</code>
	 * decryption servers, <code>w</code> of which are needed to decrypt
	 * any message encrypted by using this public key.  The values
	 * <code>v</code> and <code>vi</code> correspond to the public
	 * values <i>v</i> and
	 * <i>v<sub>i</sub></i>=<i>v</i><sup><i>l</i>!<i>s<sub>i</sub></i></sup>
	 * needed to verify the zero knowledge proofs.
	 * 
	 * @param n          a safe prime product of <i>p</i> and <i>q</i> where
	 *                   <i>p'</i>=(<i>p</i>-1)/2 and <i>a'</i>=(<i>a</i>-1)/2
	 *                   are also both primes
	 * @param l          number of decryption servers
	 * @param combineSharesConstant
	 *                   precomputed value (4<code>*l</code>!)<sup>-1</sup>
	 *                   mod <code>n</code><sup><i>s</i></sup>
	 * @param w          threshold of servers needed to successfully decrypt any
	 *                   ciphertext created by this public key.  Note that
	 *                   <code>w</code>&le;<code>l</code>/2.
	 * @param v          a generator of a cyclic group of squares in
	 *                   <i>Z</i><sup>*</sup><sub><code>n</code><sup>2</sup></sub>
	 * @param viarray    array of verification keys where <code>vi[i]</code> is
	 *                   <code>v</code><sup><code>l</code>!<i>s</i><sub><code>i</code></sub></sup>
	 *                   where <i>s</i><sub><code>i</code></sub> is the private
	 *                   key for decryption server <code>i</code>
	 * @param seed	a long integer needed to start a random number generator
	 */
	public PaillierThresholdKey(BigInteger n, int l,
			BigInteger combineSharesConstant, int w, BigInteger v,
			BigInteger[] viarray, long seed) {
		super(n, seed);
		this.l = l;
		this.delta = KeyGen.factorial(l);
		this.combineSharesConstant = combineSharesConstant;
		this.w = w;
		this.v = v;
		this.vi = viarray;
	}

	/**
	 * Creates a new public threshold key using a byte encoding of a key.
	 * 
	 * @param b			Byte array of the necessary values of this private key
	 * @param seed		a long integer needed to start a random number generator
	 * 
	 * @see #toByteArray()
	 */
	public PaillierThresholdKey(byte[] b, long seed) {
		super(ByteUtils.getLowerLayer(b), seed);
		int offset = ByteUtils.getInt(b, b.length-4);
		
		this.l = ByteUtils.getInt(b, offset);
		offset += 4;
		
		this.w = ByteUtils.getInt(b, offset);
		offset += 4;
		
		int length = ByteUtils.getInt(b, offset);
		offset += 4;
		
		this.v = ByteUtils.getBigInt(b, offset, length);
		offset += length;
		
		this.vi = new BigInteger[l];
		for (int i = 0; i < vi.length; i++) {
			length = ByteUtils.getInt(b, offset);
			this.vi[i] = ByteUtils.getBigInt(b, offset+4, length);
			offset += length + 4;
		}
	}
	
	/*
	 * 
	 * Methods
	 * 
	 */
	
	/**
	 * The public key that may be used to encrypt data for private
	 * Paillier keys.  This includes the public values of <i>v</i> and
	 * {<i>v<sub>i</sub></i>} and <i>l</i> and <i>w</i>
	 * 
	 * @return The Paillier public key corresponding to this key with
	 *         with the public verification values.
	 */
	public PaillierThresholdKey getThresholdKey(){
		return new PaillierThresholdKey(n, l, combineSharesConstant, w, 
				v, vi, rnd.nextLong());
	}

	/**
	 * Returns the public verification value.
	 * @return		verification value which generates the cyclic group
	 * 				of squares in <i>Z</i><sup>*</sup><sub><i>n</i><sup>2</sup></sub>
	 */
	public BigInteger getV() {
		return v;
	}

	/**
	 * Returns the verification keys for each decryption server.
	 * Used for verification proofs.
	 * 
	 * @return		verification keys for each of the l decryption servers
	 */
	public BigInteger[] getVi() {
		return vi;
	}

	/**
	 * Returns the number of decryption servers.
	 * @return		the number of decryption servers
	 */
	public int getL() {
		return l;
	}

	/**
	 * Returns the cached value &Delta;=<i>l</i>! where <i>l</i> is the
	 * number of decryption servers.  This is frequently used for
	 * decryption.
	 * 
	 * @return		the value <code>l</code>!
	 */
	public BigInteger getDelta() {
		return delta;
	}

	/**
	 * Returns the threshold number of decryption servers needed to
	 * successfully decrypt any ciphertext created by this key.
	 * 
	 * @return		the minimum number of decryption servers needed
	 * 				to make a correct decryption
	 */
	public int getW() {
		return w;
	}

	/**
	 * Returns a cached value of (4*&Delta;)<sup>-1</sup> mod <i>n</i>.
	 * This value is heavily used for decryption.
	 * 
	 * @return		the inverse of (4&Delta;) in <i>Z<sub>n</sub></i>
	 */
	public BigInteger getCombineSharesConstant() {
		return this.combineSharesConstant;
	}
	
	/**
	 * Encodes this key into a byte array.  As this is a public threshold key,
	 * the public modulo {@code n}, {@code l}, {@code w}, {@code v}, and
	 * {@code vi} will be encoded in that order.
	 * Further, before each BigInteger (except {@code n}) is the 4-byte
	 * equivalent to the size of the BigInteger for later parsing.
	 * 
	 * @return			a byte array containing the most necessary values
	 * 					of this key.  A byte array of size 0 is returned
	 * 					if the key would be too large.
	 * 
	 * @see #PaillierThresholdKey(byte[], long)
	 * @see BigInteger#toByteArray()
	 */
	public byte[] toByteArray() {
		// The encoding would be:
		// [ prev. layer ]
		// [ l ]
		// [ w ]
		// [ length of v ]
		// [ v ]
		// [ length of v1 ]
		// [ v1 ]
		// ...
		// [ length of vl ]
		// [ vl]
		// [ length of previous layer ]
		
		byte[] p = super.toByteArray();		// previous layer
		
		byte[] r = ByteUtils.appendInt(p, l, w);
		if (r.length == 0) { return r; }
		r = ByteUtils.appendBigInt(p, v);
		if (r.length == 0) { return r; }
		r = ByteUtils.appendBigInt(p, vi);
		if (r.length == 0) { return r; }
		r = ByteUtils.appendInt(r, p.length);
		
		return r;
	}
}
